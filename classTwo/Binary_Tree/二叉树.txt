节点的高度：节点到叶子节点的最长路径（边数）
节点的深度：根节点到这个节点经历的边的个数
节点的层数：节点的深度+1
树的高度：根节点的高度

叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫作满二叉树。
叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫作完全二叉树。

想要存储一棵二叉树，我们有两种方法：
一种是基于指针或者引用的二叉链式存储法
一种是基于数组的顺序存储法
基于数组的顺序存储法。我们把根节点存储在下标 i = 1 的位置，那左子节点存储在下标 2 * i = 2 的位置，右子节点存储在 2 * i + 1 = 3 的位置。以此类推
遵守共同的规则（左节点都是2i，右节点都是2i+1），确实可以减少存储空间，提高效率


二叉树的遍历，递归遍历时间复杂度是 O(n)。
写递归代码的关键，就是看能不能写出递推公式，而写递推公式的关键就是，如果要解决问题 A，就假设子问题 B、C 已经解决，然后再来看如何利用 B、C 来解决 A。


给定一组数据，比如 1，3，5，6，9，10。你来算算，可以构建出多少种不同的二叉树？
如果要按照顺序，可以递归考虑，假如后n-1个数据已经组成了x种不同二叉树，第1个数据可以和他们组合成，2x种不同二叉树，即2^n种
如果不按照顺序，应该有n的阶乘个组合


按层遍历，如何实现？
就是广度优先遍历在二叉树结构上的应用，利用队列，先将根节点入队，打印，出队时放入它的左右孩子节点，循环直到队列为空












