把每一层重复的状态（节点）合并，只记录不同的状态，然后基于上一层的状态集合，来推导下一层的状态集合。
我们把问题分解为多个阶段，每个阶段对应一个决策。
我们记录每一个阶段可达的状态集合（去掉重复的），然后通过当前阶段的状态集合，来推导下一个阶段的状态集合，动态地往前推进。

什么样的问题适合用动态规划来解决呢？换句话说，动态规划能解决的问题有什么规律可循呢？
“一个模型三个特征”。
什么是“一个模型”？它指的是动态规划适合解决的问题的模型。我把这个模型定义为“多阶段决策最优解模型”。
我们一般是用动态规划来解决最优问题。而解决问题的过程，需要经历多个决策阶段。
每个决策阶段都对应着一组状态。然后我们寻找一组决策序列，经过这组决策序列，能够产生最终期望求解的最优值。

什么是“三个特征”？它们分别是最优子结构、无后效性和重复子问题。
1. 最优子结构
最优子结构指的是，问题的最优解包含子问题的最优解。反过来说就是，我们可以通过子问题的最优解，推导出问题的最优解。
如果我们把最优子结构，对应到我们前面定义的动态规划问题模型上，那我们也可以理解为，后面阶段的状态可以通过前面阶段的状态推导出来。
2. 无后效性
无后效性有两层含义，第一层含义是，在推导后面阶段的状态的时候，我们只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。
第二层含义是，某阶段状态一旦确定，就不受之后阶段的决策影响。
无后效性是一个非常“宽松”的要求。只要满足前面提到的动态规划问题模型，其实基本上都会满足无后效性。
3. 重复子问题
这个概念比较好理解。前面一节，我已经多次提过。如果用一句话概括一下，那就是，不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。

两种动态规划解题思路总结
1. 状态转移表法
一般能用动态规划解决的问题，都可以使用回溯算法的暴力搜索解决。
所以，当我们拿到问题的时候，我们可以先用简单的回溯算法解决，然后定义状态，每个状态表示一个节点，然后对应画出递归树。
从递归树中，我们很容易可以看出来，是否存在重复子问题，以及重复子问题是如何产生的。以此来寻找规律，看是否能用动态规划解决。
找到重复子问题之后，接下来，使用动态规划的解决方法，状态转移表法。
我们先画出一个状态表。状态表一般都是二维的，所以你可以把它想象成二维数组。其中，每个状态包含三个变量，行、列、数组值。
我们根据决策的先后过程，从前往后，根据递推关系，分阶段填充状态表中的每个状态。最后，我们将这个递推填表的过程，翻译成代码，就是动态规划代码了。
回溯算法实现 - 定义状态 - 画递归树 - 找重复子问题 - 画状态转移表 - 根据递推关系填表 - 将填表过程翻译成代码。
2. 状态转移方程法
状态转移方程法有点类似递归的解题思路。我们需要分析，某个问题如何通过子问题来递归求解，也就是所谓的最优子结构。
根据最优子结构，写出递归公式，也就是所谓的状态转移方程。有了状态转移方程，代码实现就非常简单了。
强调一下，状态转移方程是解决动态规划的关键。如果我们能写出状态转移方程，那动态规划问题基本上就解决一大半了，而翻译成代码非常简单。
但是很多动态规划问题的状态本身就不好定义，状态转移方程也就更不好想到。
找最优子结构 - 写状态转移方程 - 将状态转移方程翻译成代码。

硬币找零问题，我们在贪心算法那一节中讲过一次。我们今天来看一个新的硬币找零问题。
假设我们有几种不同币值的硬币 v1，v2，……，vn（单位是元）。如果我们要支付 w 元，求最少需要多少个硬币。
比如，我们有 3 种不同的硬币，1 元、3 元、5 元，我们要支付 9 元，最少需要 3 个硬币（3 个 3 元的硬币）。
答---使用动态规划解决问题一般分为三步：
1.表示状态 f(n)表示，凑够n元需要的最少硬币数,在之前的总钱数每次增加1枚硬币会改变状态
2.找出状态转移方程  f(n) = 1 + min(f(n-1), f(n-3), f(n-5))
3.边界处理 f(1) = 1 f(3) = 1 f(5) =1 

我们有一个数字序列包含 n 个不同的数字，如何求出这个序列中的最长递增子序列长度？
比如 2, 9, 3, 6, 5, 1, 7 这样一组数字序列，它的最长递增子序列就是 2, 3, 5, 7，所以最长递增子序列的长度是 4。

1.算法思想选择
状态连续，不用分治，考虑回溯思想
2.定义状态
状态包含2个变量 (i, subLen), i代表遍历到原序列第i位，subLen 表示目前子序列的长度

递增最长子序列 var SubSequence []int ，里面存储原序列中的数字，添加时要保证后一个要比前一位大
最大长度MaxSubLen = len(SubSequence)
原序列每个数字，都有添加或者不添加两种可能性
剪枝，根据原序列第i位是否大于最长子序列的最后一位，来判断是否添加


3.画递归树 
在递归树中，每个节点代表一个状态，
4.找到重复子问题
如果存在重复子问题，那我们就可以考虑能否用动态规划来解决；如果不存在重复子问题，那回溯就是最好的解决方法。
对于 (i) 相同的节点，我们只需要保留 subLen 最大的，继续递归处理就可以了，剩下的节点都可以舍弃。
所以，状态就从 (i, subLen) 变成了 (i, MaxSubLen)
5.画状态转移表 


6.根据递推关系填表


7.将填表过程翻译成代码
var MaxSubLen int = -1
var nums []int = []int{2, 9, 5, 6, 5, 1, 7}
var SubSequence []int = make([]int, 0)

func findMaxSubSequence(SubSequence , nums []int, i int){
    if MaxSubLen < len(SubSequence){
        MaxSubLen = len(SubSequence)
    }
    if i > len(nums)-1{ //终止条件
        return  
    }

    if SubSequence[len(SubSequence)-1] < nums[i]{  //符合递增条件再考虑下一步
        SubSequence = SubSequence                  //不添加原序列第i位到子序列
        findMaxSubSequence(SubSequence , nums, i+1)

        SubSequence = append(SubSequence, nums[i]) //添加原序列第i位到子序列
        findMaxSubSequence(SubSequence , nums, i+1) 
    }
}
以上算法有错误，**不添加就不用考虑递增条件**

以上过程感觉相当繁琐，感觉还是直接用状态转移方程法清晰明了
找最优子结构 - 写状态转移方程 - 将状态转移方程翻译成代码。
1.表示状态
 maxSubLen(i,j) 表示，遍历到序列第i位，子序列长度为j
2.找出状态转移方程  
maxSubLen(i,j)  = max( maxSubLen(i-1,j-1)+1, maxSubLen(i-1,j))
3.边界处理 
maxSubLen(0,0) = 0 maxSubLen(0,1) = 1
感觉这个问题用动态规划不好理解，不合适，用回溯法好理解












