数据库索引是如何实现的呢？底层使用的是什么数据结构和算法呢？
1. 解决问题的前提是定义清楚问题
这里我们假设要解决的问题，只包含这样两个常用的需求：
根据某个值查找数据，比如 select * from user where id=1234；
根据区间值来查找某些数据，比如 select * from user where id > 1234 and id < 2345。
性能方面的需求，我们主要考察时间和空间两方面，也就是执行效率和存储空间。

2.尝试用学过的数据结构解决这个问题
我们先来看散列表。散列表的查询性能很好，时间复杂度是 O(1)。但是，散列表不能支持按照区间快速查找数据。所以，散列表不能满足我们的需求。
我们再来看平衡二叉查找树。尽管平衡二叉查找树查询的性能也很高，时间复杂度是 O(logn)。
而且，对树进行中序遍历，我们还可以得到一个从小到大有序的数据序列，但这仍然不足以支持按照区间快速查找数据。
我们再来看跳表。跳表是在链表之上加上多层索引构成的。它支持快速地插入、查找、删除数据，对应的时间复杂度是 O(logn)。
并且，跳表也支持按照区间快速地查找数据。我们只需要定位到区间起点值对应在链表中的结点，
然后从这个结点开始，顺序遍历链表，直到区间终点对应的结点为止，这期间遍历得到的数据就是满足区间值的数据。

这样看来，跳表是可以解决这个问题。实际上，数据库索引所用到的数据结构跟跳表非常相似，叫作 B+ 树。不过，它是通过二叉查找树演化过来的，而非跳表。

3. 改造二叉查找树来解决这个问题
为了让二叉查找树支持按照区间来查找数据，我们可以对它进行这样的改造：树中的节点并不存储数据本身，而是只是作为索引。
除此之外，我们把每个叶子节点串在一条链表上，链表中的数据是从小到大有序的。
不过，为了节省内存，如果把树存储在硬盘中，那么每个节点的读取（或者访问），都对应一次磁盘 IO 操作。树的高度就等于每次查询数据时磁盘 IO 操作的次数。
比起内存读写操作，磁盘 IO 操作非常耗时，所以我们优化的重点就是尽量减少磁盘 IO 操作，也就是，尽量降低树的高度。那如何降低树的高度呢？
如果我们把索引构建成 m 叉树，高度是不是比二叉树要小呢？
不管是内存中的数据，还是磁盘中的数据，操作系统都是按页（一页大小通常是 4KB，这个值可以通过 getconfig PAGE_SIZE 命令查看）来读取的，
一次会读一页的数据。如果要读取的数据量超过一页的大小，就会触发多次 IO 操作。
所以，我们在选择 m 大小的时候，要尽量让每个节点的大小等于一个页的大小。读取一个节点，只需要一次磁盘 IO 操作。
如果叶子节点是16K，那么存储256个叶子一个父节点合适
对于一个 B+ 树来说，m 值是根据页的大小事先计算好的，也就是说，每个节点最多只能有 m 个子节点。
在往数据库中写入数据的过程中，这样就有可能使索引中某些节点的子节点个数超过 m，
处理思路并不复杂。我们只需要将这个节点分裂成两个节点。但是，节点分裂之后，其上层父节点的子节点个数就有可能超过 m 个。
不过这也没关系，我们可以用同样的方法，将父节点也分裂成两个节点。

B+ 树发明于 1972 年，跳表发明于 1989 年

总结一下 B+ 树的特点：
每个节点中子节点的个数不能超过 m，也不能小于 m/2；
根节点的子节点个数可以不超过 m/2，这是一个例外；
m 叉树只存储索引，并不真正存储数据，这个有点儿类似跳表；
通过链表将叶子节点串联在一起，这样可以方便按区间查找； 
一般情况，根节点会被存储在内存中，其他节点存储在磁盘中。

B 树只是一个每个节点的子节点个数不能小于 m/2 的 m 叉树。
