如何通过源文件两两之间的局部依赖关系，确定一个全局的编译顺序呢？

我们可以把源文件与源文件之间的依赖关系，抽象成一个有向图。每个源文件对应图中的一个顶点，源文件之间的依赖关系就是顶点之间的边。
如果 a 先于 b 执行，也就是说 b 依赖于 a，那么就在顶点 a 和顶点 b 之间，构建一条从 a 指向 b 的边。
而且，这个图不仅要是有向图，还要是一个有向无环图，也就是不能存在像 a->b->c->a 这样的循环依赖关系。
因为图中一旦出现环，拓扑排序就无法工作了。实际上，拓扑排序本身就是基于有向无环图的一个算法。

拓扑排序有两种实现方法，都不难理解。它们分别是 Kahn 算法和 DFS 深度优先搜索算法。我们依次来看下它们都是怎么工作的。
1.Kahn 算法
Kahn 算法实际上用的是贪心算法思想，思路非常简单、好懂。
定义数据结构的时候，如果 s 需要先于 t 执行，那就添加一条 s 指向 t 的边。
所以，如果某个顶点入度为 0， 也就表示，没有任何顶点必须先于这个顶点执行，那么这个顶点就可以执行了。
我们先从图中，找出一个入度为 0 的顶点，将其输出到拓扑排序的结果序列中（对应代码中就是把它打印出来），
并且把这个顶点从图中删除（也就是把这个顶点可达的顶点的入度都减 1）。
我们循环执行上面的过程，直到所有的顶点都被输出。最后输出的序列，就是满足局部依赖关系的拓扑排序。
从 Kahn 代码中可以看出来，每个顶点被访问了一次，每个边也都被访问了一次，
所以，Kahn 算法的时间复杂度就是 O(V+E)（V 表示顶点个数，E 表示边的个数）。

2.DFS 算法
这个算法包含两个关键部分。
第一部分是通过邻接表构造逆邻接表。邻接表中，边 s->t 表示 s 先于 t 执行，也就是 t 要依赖 s。
在逆邻接表中，边 s->t 表示 s 依赖于 t，s 后于 t 执行。为什么这么转化呢？这个跟我们这个算法的实现思想有关。
第二部分是这个算法的核心，也就是递归处理每个顶点。
对于顶点 vertex 来说，我们先输出它可达的所有顶点，也就是说，先把它依赖的所有的顶点输出了，然后再输出自己。
DFS 算法的时间复杂度我们之前分析过。每个顶点被访问两次，每条边都被访问一次，所以时间复杂度也是 O(V+E)。


拓扑排序应用非常广泛，解决的问题的模型也非常一致。凡是需要通过局部顺序来推导全局顺序的，一般都能用拓扑排序来解决。
除此之外，拓扑排序还能检测图中环的存在。
对于 Kahn 算法来说，如果最后输出出来的顶点个数，少于图中顶点个数，图中还有入度不是 0 的顶点，那就说明，图中存在环。

思考1：在今天的讲解中，我们用图表示依赖关系的时候，如果 a 先于 b 执行，我们就画一条从 a 到 b 的有向边；反过来，
如果 a 先于 b，我们画一条从 b 到 a 的有向边，表示 b 依赖 a，
那今天讲的 Kahn 算法和 DFS 算法还能否正确工作呢？如果不能，应该如何改造一下呢？
Kahn 算法,要改为每个点要递归增加前面依赖的节点的入度，这样入度最大的节点就是起点
DFS 算法，正常，因为之前也需要构造逆邻接表

思考2：我们今天讲了两种拓扑排序算法的实现思路，Kahn 算法和 DFS 深度优先搜索算法，如果换做 BFS 广度优先搜索算法，还可以实现吗？
可以，类似DFS 先通过邻接表构造逆邻接表，广度优先遍历后的结果，存入栈中，最后再弹出，就是顺序

