本质是将 要存储的数据 如何和数组下标（内存连续编码）一一对应，迅速用数据就找到存储地址
[]string,[]struct{},结构体中就可以存入其他相关信息
主要用途还是查找，有无重复元素，有无之前存入的元素，查找之前存入的其他相关信息

首先，散列函数的设计不能太复杂。
    过于复杂的散列函数，势必会消耗很多计算时间，也就间接的影响到散列表的性能。
其次，散列函数生成的值要尽可能随机并且均匀分布，
    这样才能避免或者最小化散列冲突，而且即便出现冲突，散列到每个槽里的数据也会比较平均，不会出现某个槽内数据特别多的情况
例如：
将单词中每个字母的ASCll 码值“进位”相加，然后再跟散列表的大小求余(都会有这一步)、取模，作为散列值。比如，英文单词 nice，我们转化出来的散列值就是下面这样：
hash("nice")=(("n" - "a") * 26*26*26 + ("i" - "a")*26*26 + ("c" - "a")*26+ ("e"-"a")) / 78978

装载因子过大了怎么办？
针对数组的扩容，数据搬移操作比较简单。但是，针对散列表的扩容，数据搬移操作要复杂很多
因为散列表的大小变了，数据的存储位置也变了，所以我们需要通过散列函数重新计算每个数据的存储位置。

如何避免低效地扩容？
为了解决一次性扩容耗时过多的情况，我们可以将扩容操作穿插在插入操作的过程中，分批完成。
这期间的查询操作怎么来做呢？对于查询操作，为了兼容了新、老散列表中的数据，我们先从新散列表中查找，如果没有找到，再去老的散列表中查找。

如何选择冲突解决方法？
1. 开放寻址法
当数据量比较小、装载因子小的时候，适合采用开放寻址法。这也是 Java 中的ThreadLocalMap使用开放寻址法解决散列冲突的原因。
2. 链表法
首先，链表法对内存的利用率比开放寻址法要高。
实际上，我们对链表法稍加改造，可以实现一个更加高效的散列表。那就是，我们将链表法中的链表改造为其他高效的动态数据结构，比如跳表、红黑树。
基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表.

工业级散列表举例分析
Java 中的 HashMap 这样一个工业级的散列表
1. 初始大小HashMap 
默认的初始大小是 16
2. 装载因子和动态扩容
最大装载因子默认是 0.75，
当 HashMap 中元素个数超过 0.75*capacity（capacity 表示散列表的容量）的时候，就会启动扩容，每次扩容都会扩容为原来的两倍大小。
3. 散列冲突解决方法
HashMap 底层采用链表法来解决冲突。而当链表长度太长（默认超过 8）时，链表就转换为红黑树。
4. 散列函数
散列函数的设计并不复杂，追求的是简单高效、分布均匀。
非常简洁，有效
int hash(Object key) {
    int h = key.hashCode()；
    return (h ^ (h >>> 16)) & (capicity -1); //capicity表示散列表的大小
}