涉及到查找还是散列速度快，涉及到删除、新增，链表结构好用，强强联合，大数量级适用

LRU 缓存淘汰算法
一个缓存（cache）系统主要包含下面这几个操作：
往缓存中添加一个数据；
从缓存中删除一个数据；
在缓存中查找一个数据。
散列表+双向链表
链表中的每个结点处理存储数据（data）、前驱指针（prev）、后继指针（next）之外，还新增了一个特殊的字段 hnext。
因为我们的散列表是通过链表法解决散列冲突的，所以每个结点会在两条链中。一个链是刚刚我们提到的双向链表，另一个链是散列表中的拉链。
前驱和后继指针是为了将结点串在双向链表中，hnext 指针是为了将结点串在散列表的拉链中。

Redis 有序集合
我们可以再按照键值构建一个散列表，这样按照 key 来删除、查找一个成员对象的时间复杂度就变成了 O(1)。同时，借助跳表结构，其他操作也非常高效。
基础数据存储上，可以添加很多新数据结构来完成不同功能，可以多次扩展
链表 + 跳表 + 散列

散列表这种数据结构虽然支持非常高效的数据插入、删除、查找操作，但是散列表中的数据都是通过散列函数打乱之后无规律存储的。
也就说，它无法支持按照某种顺序快速地遍历数据。如果希望按照顺序遍历散列表中的数据，那我们需要将散列表中的数据拷贝到数组中，然后排序，再遍历。
因为散列表是动态数据结构，不停地有数据的插入、删除，所以每当我们希望按顺序遍历散列表中的数据的时候，都需要先排序，那效率势必会很低。
为了解决这个问题，我们将散列表和链表（或者跳表）结合在一起使用。
（链表顺序遍历才方便）

“通过这 20 节课学习下来，个人感觉其实就两种数据结构，链表和数组。
数组占据随机访问的优势，却有需要连续内存的缺点。
链表具有可不连续存储的优势，但访问查找是线性的。
散列表和链表、跳表的混合使用，是为了结合数组和链表的优势，规避它们的不足。”