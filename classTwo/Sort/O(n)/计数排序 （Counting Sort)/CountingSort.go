/*
计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，
计数排序要求输入的数据必须是有确定范围的整数。
特殊情况下，某种算法少做无用功，效率会高。计数排序省去了比较操作，时间复杂度为O(n+k)，一遍排序为O(nlogn)
一定范围内的数字，可以计算偏移量的字母等排序都可以用计数排序，k很大时，失去优势。

1. 计数排序的特征
当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 Θ(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。

由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。

通俗地理解，例如有 10 个年龄不同的人，统计出有 8 个人的年龄比 A 小，那 A 的年龄就排在第 9 位,用这个方法可以得到其他每个人的位置,也就排好了序。当然，年龄有重复时需要特殊处理（保证稳定性），这就是为什么最后要反向填充目标数组，以及将每个数字的统计减去 1 的原因。

 算法的步骤如下：

（1）找出待排序的数组中最大和最小的元素
（2）统计数组中每个值为i的元素出现的次数，存入数组C的第i项
（3）对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）
（4）反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1

算是桶排序的一种特例，相当于每个桶中只放1个数字，这样就省去了桶内排序，但需要创建非常多桶

计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。
而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。
比如，还是拿考生这个例子。如果考生成绩精确到小数后一位，我们就需要将所有的分数都先乘以 10，转化成整数，然后再放到 9010 个桶内。
再比如，如果要排序的数据中有负数，数据的范围是[-1000, 1000]，那我们就需要先对每个数据都加 1000，转化成非负整数。
*/
package main

import "fmt"

func countingSort(arr []int, maxValue int) []int {
	bucketLen := maxValue + 1
	bucket := make([]int, bucketLen) // 初始为0的数组

	length := len(arr)
	for i := 0; i < length; i++ {
		bucket[arr[i]]++ //下标映射为实际数字，计数每个数字出现次数
	}
	fmt.Println(bucket)

	sortedIndex := 0
	for j := 0; j < bucketLen; j++ {
		for bucket[j] > 0 {
			arr[sortedIndex] = j //j代表实际数字，从0开始依次增加
			sortedIndex++
			bucket[j]--
		}
	}

	return arr
}

func main() {
	nums := []int{5, 6, 9, 3, 2, 1, 6, 8, 9, 4, 3}
	nums = countingSort(nums, 9)
	fmt.Println(nums)
}
