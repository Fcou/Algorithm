1. 最好情况、最坏情况、平均情况时间复杂度

2. 时间复杂度的系数、常数 、低阶

3. 比较次数和交换（或移动）次数

4. 排序算法的内存消耗

5. 排序算法的稳定性:
针对排序算法，我们还有一个重要的度量指标，稳定性。这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。
比如说，我们现在要给电商交易系统中的“订单”排序。订单有两个属性，一个是下单时间，另一个是订单金额。
如果我们现在有 10 万条订单数据，我们希望按照金额从小到大对订单数据排序。
对于金额相同的订单，我们希望按照下单时间从早到晚有序。对于这样一个排序需求，我们怎么来做呢？
答案：稳定排序算法可以保持金额相同的两个对象，在排序之后的前后顺序不变。第一次排序之后，所有的订单按照下单时间从早到晚有序了。
在第二次排序中，我们用的是稳定的排序算法，所以经过第二次排序之后，相同金额的订单仍然保持下单时间从早到晚有序。
        冒泡排序     插入排序     选择排序
原地排序    是         是           是
稳定排序    是         是           否
最好时间   O(n)       O(n)        O(n)
最坏时间   O(n2)      O(n2)       O(n2)
平均时间   O(n2)      O(n2)       O(n2)
从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。冒泡、插入、选择排序，这3个中插入排序最优

        归并排序      快速排序     
原地排序  否O(n)         是          
稳定排序    是           否         
最好时间  O(nlogn)     O(nlogn)         
最坏时间  O(nlogn)      O(n2)       
平均时间  O(nlogn)     O(nlogn)        
归并排序和快速排序是两种稍微复杂的排序算法，它们用的都是分治的思想，代码都通过递归来实现，过程非常相似。
理解归并排序的重点是理解递推公式和 merge() 合并函数。同理，理解快排的重点也是理解递推公式，还有 partition() 分区函数。

桶排序、计数排序、基数排序。因为这些排序算法的时间复杂度是线性的，所以我们把这类排序算法叫作线性排序（Linear sort）。
之所以能做到线性的时间复杂度，主要原因是，这三个算法是非基于比较的排序算法，都不涉及元素之间的比较操作。
         桶排序       计数排序       基数排序 
原地排序  否O(n)        否O(n)       否O(n)  
稳定排序    是           否            是
最好时间  O(n)          O(n)         O(n)
最坏时间  O(nlogn)      O(n)         O(n)
平均时间  O(n)          O(n)         O(n)



