一种特殊的树，“堆”（Heap）。堆这种数据结构的应用场景非常多，最经典的莫过于堆排序了。
堆排序是一种原地的、时间复杂度为 O(nlogn) 的排序算法。
只要满足这两点，它就是一个堆。
堆是一个完全二叉树；
堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。

如何实现一个堆？
完全二叉树比较适合用数组来存储。用数组来存储完全二叉树是非常节省存储空间的。
1. 往堆中插入一个元素
如果我们把新插入的元素放到堆的最后，进行调整，让其重新满足堆的特性
2. 删除堆顶元素
把最后一个节点放到堆顶，然后利用同样的父子节点对比方法。
对于不满足父子节点大小关系的，互换两个节点，并且重复进行这个过程，直到父子节点之间满足大小关系为止。这就是从上往下的堆化方法。
往堆中插入一个元素和删除堆顶元素的时间复杂度都是 O(logn)。

堆排序
把堆排序的过程大致分解成两个大的步骤，建堆和排序。.
1. 建堆
第一种是借助我们前面讲的，在堆中插入一个元素的思路。尽管数组中包含 n 个数据，但是我们可以假设，起初堆中只包含一个数据，就是下标为 1 的数据。然后，我们调用前面讲的插入操作，将下标从 2 到 n 的数据依次插入到堆中。这样我们就将包含 n 个数据的数组，组织成了堆。
第二种实现思路，跟第一种截然相反，实现思路，是从后往前处理数组，并且每个数据都是从上往下堆化。直接从第一个非叶子节点开始，依次堆化就行了。
对于完全二叉树来说，下标从 2n​+1 到 n 的节点都是叶子节点
建堆的时间复杂度就是 O(n)。
2. 排序
当堆顶元素移除之后，我们把下标为 n 的元素放到堆顶，然后再通过堆化的方法，将剩下的 n−1 个元素重新构建成堆
堆排序不是稳定的排序算法

在实际开发中，为什么快速排序要比堆排序性能好？
第一点，堆排序数据访问的方式没有快速排序友好。
第二点，对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序。

在讲堆排序建堆的时候，我说到，对于完全二叉树来说，下标从 n/2​+1 到 n 的都是叶子节点，这个结论是怎么推导出来的呢？
i节点的左孩子是2i右孩子是2i+1，假设2i = n 则 i= n/2 ,i为最后一个有左孩子的节点，之后的节点不可能有孩子节点，所以n/2​+1 到 n 的都是叶子节点

我们今天讲了堆的一种经典应用，堆排序。关于堆，你还能想到它的其他应用吗？
堆的应用一：优先级队列
一个堆就可以看作一个优先级队列。很多时候，它们只是概念上的区分而已。往优先级队列中插入一个元素，就相当于往堆中插入一个元素；从优先级队列中取出优先级最高的元素，就相当于取出堆顶元素。
1. 合并有序小文件
假设我们有 100 个小文件，每个文件的大小是 100MB，每个文件中存储的都是有序的字符串。我们希望将这些 100 个小文件合并成一个有序的大文件。
这里就可以用到优先级队列，也可以说是堆。我们将从小文件中取出来的字符串放入到小顶堆中，那堆顶的元素，也就是优先级队列队首的元素，就是最小的字符串。
我们将这个字符串放入到大文件中，并将其从堆中删除。然后再从小文件中取出下一个字符串，放入到堆中。循环这个过程，就可以将 100 个小文件中的数据依次放入到大文件中。
2. 高性能定时器
假设我们有一个定时器，定时器中维护了很多定时任务，每个任务都设定了一个要触发执行的时间点。定时器每过一个很小的单位时间（比如 1 秒），就扫描一遍任务，看是否有任务到达设定的执行时间。如果到达了，就拿出来执行。
我们按照任务设定的执行时间，将这些任务存储在优先级队列中，队列首部（也就是小顶堆的堆顶）存储的是最先执行的任务。
它拿队首任务的执行时间点，与当前时间点相减，得到一个时间间隔 T。
这样，定时器就可以设定在 T 秒之后，再来执行任务。当 T 秒时间过去之后，定时器取优先级队列中队首的任务执行。然后再计算新的队首任务的执行时间点与当前时间点的差值.

堆的应用二：利用堆求 Top K
求 Top K 的问题抽象成两类。
1.一类是针对静态数据集合，也就是说数据集合事先确定，不会再变。
针对静态数据，如何在一个包含 n 个数据的数组中，查找前 K 大数据呢？我们可以维护一个大小为 K 的小顶堆，顺序遍历数组，从数组中取出数据与堆顶元素比较。
如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理，继续遍历数组。这样等数组中的数据都遍历完之后，堆中的数据就是前 K 大数据了。
2.另一类是针对动态数据集合，也就是说数据集合事先并不确定，有数据动态地加入到集合中。
我们可以一直都维护一个 K 大小的小顶堆，当有数据被添加到集合中时，我们就拿它与堆顶的元素对比。如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理。这样，无论任何时候需要查询当前的前 K 大数据，我们都可以立刻返回给他

堆的应用三：利用堆求中位数,求前10%同理
我们需要维护两个堆，一个大顶堆，一个小顶堆。大顶堆中存储前半部分数据，小顶堆中存储后半部分数据，且小顶堆中的数据都大于大顶堆中的数据。
插入数据因为需要涉及堆化，所以时间复杂度变成了 O(logn)，但是求中位数我们只需要返回大顶堆的堆顶元素就可以了，所以时间复杂度就是 O(1)。

假设现在我们有一个包含 10 亿个搜索关键词的日志文件，如何快速获取到 Top 10 最热门的搜索关键词呢？
我们假设 10 亿条搜索关键词中不重复的有 1 亿条，如果每个搜索关键词的平均长度是 50 个字节，那存储 1 亿个关键词起码需要 5GB 的内存空间
将 10 亿条搜索关键词先通过哈希算法分片到 10 个文件中。我们创建 10 个空文件 00，01，02，……，09。我们遍历这 10 亿个关键词，并且通过某个哈希算法对其求哈希值，然后哈希值同 10 取模，得到的结果就是这个搜索关键词应该被分到的文件编号。
我们针对每个包含 1 亿条搜索关键词的文件，利用散列表和堆，分别求出 Top 10，然后把这个 10 个 Top 10 放在一块，然后取这 100 个关键词中，出现次数最多的 10 个关键词，这就是这 10 亿数据中的 Top 10 最频繁的搜索关键词了。

有一个访问量非常大的新闻网站，我们希望将点击量排名 Top 10 的新闻摘要，滚动显示在网站首页 banner 上，并且每隔 1 小时更新一次。怎么做？
每一小时统计一次点击量，建立大根堆，依次取出十个最大值，滚动显示更新。
不应该实时维护，实时维护意味着每秒都执行一次上述计算，动态维护计算量太大。
---------------------------------------
要搞清楚点击量是何时开始算，按照理解是每小时应该清零，定义为之前一小时点击量最大新闻，如果不够的话，可以统计每日，每周点击量最大新闻















