一种特殊的树，“堆”（Heap）。堆这种数据结构的应用场景非常多，最经典的莫过于堆排序了。
堆排序是一种原地的、时间复杂度为 O(nlogn) 的排序算法。
只要满足这两点，它就是一个堆。
堆是一个完全二叉树；
堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。

如何实现一个堆？
完全二叉树比较适合用数组来存储。用数组来存储完全二叉树是非常节省存储空间的。
1. 往堆中插入一个元素
如果我们把新插入的元素放到堆的最后，进行调整，让其重新满足堆的特性
2. 删除堆顶元素
把最后一个节点放到堆顶，然后利用同样的父子节点对比方法。
对于不满足父子节点大小关系的，互换两个节点，并且重复进行这个过程，直到父子节点之间满足大小关系为止。这就是从上往下的堆化方法。
往堆中插入一个元素和删除堆顶元素的时间复杂度都是 O(logn)。

堆排序
把堆排序的过程大致分解成两个大的步骤，建堆和排序。.
1. 建堆
第一种是借助我们前面讲的，在堆中插入一个元素的思路。尽管数组中包含 n 个数据，但是我们可以假设，起初堆中只包含一个数据，就是下标为 1 的数据。然后，我们调用前面讲的插入操作，将下标从 2 到 n 的数据依次插入到堆中。这样我们就将包含 n 个数据的数组，组织成了堆。
第二种实现思路，跟第一种截然相反，实现思路，是从后往前处理数组，并且每个数据都是从上往下堆化。直接从第一个非叶子节点开始，依次堆化就行了。
对于完全二叉树来说，下标从 2n​+1 到 n 的节点都是叶子节点
建堆的时间复杂度就是 O(n)。
2. 排序
当堆顶元素移除之后，我们把下标为 n 的元素放到堆顶，然后再通过堆化的方法，将剩下的 n−1 个元素重新构建成堆
堆排序不是稳定的排序算法

在实际开发中，为什么快速排序要比堆排序性能好？
第一点，堆排序数据访问的方式没有快速排序友好。
第二点，对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序。

在讲堆排序建堆的时候，我说到，对于完全二叉树来说，下标从 n/2​+1 到 n 的都是叶子节点，这个结论是怎么推导出来的呢？
i节点的左孩子是2i右孩子是2i+1，假设2i = n 则 i= n/2 ,i为最后一个有左孩子的节点，之后的节点不可能有孩子节点，所以n/2​+1 到 n 的都是叶子节点

我们今天讲了堆的一种经典应用，堆排序。关于堆，你还能想到它的其他应用吗？
1.topK  // 排序求前k位置
2.流里面的中值  
3.流里面的中位数 //流，就是动态增删的数据，维护一个最大堆和一个最小堆